<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Space Brownian Battle</title>
    <style>
        :root {
            color-scheme: dark light;
            --bg: #0b0f1a;
            --panel: rgba(255,255,255,0.08);
            --text: #f5f6fa;
            --accent: #2c7be5;
            --danger: #ff6b6b;
            --success: #51cf66;
        }
        body {
            margin: 0;
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        header, footer {
            max-width: 900px;
            width: 100%;
        }
        header {
            margin-bottom: 1rem;
        }
        h1 {
            margin: 0 0 0.5rem;
            letter-spacing: 0.08em;
        }
        p {
            margin: 0.25rem 0;
            opacity: 0.85;
        }
        canvas {
            background: radial-gradient(circle at center, #1e293b 20%, #0b1326 100%);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.45);
            max-width: 100%;
        }
        .hud {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .panel {
            background: var(--panel);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(6px);
        }
        label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }
        input[type="range"] {
            width: 160px;
        }
        .status {
            margin-top: 1rem;
            min-height: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        footer {
            margin-top: 2rem;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        a {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <header>
        <h1>Space Brownian Battle</h1>
        <p>Use as setas para mover a nave; a barra de espaço dispara. Derrube as 5 naves inimigas antes de sofrer 3 colisões.</p>
    </header>

    <section class="hud">
        <div class="panel">
            <div><strong>Pontos:</strong> <span id="score">0</span> / 5</div>
            <div><strong>Colisões sofridas:</strong> <span id="hits">0</span> / 3</div>
        </div>
        <div class="panel">
            <label>
                Velocidade do tiro
                <input type="range" id="bulletSpeed" min="250" max="650" step="10" value="450">
                <span id="bulletSpeedValue">450</span>
            </label>
            <label>
                Inércia inimiga
                <input type="range" id="inertia" min="0" max="1" step="0.05" value="0.8">
                <span id="inertiaValue">0.80</span>
            </label>
        </div>
    </section>

    <canvas id="game" width="800" height="600"></canvas>
    <div class="status" id="status"></div>

    <footer>
        <p>Arquivo único pronto para GitHub Pages. Basta enviar este HTML para o repositório e ativar o Pages.</p>
    </footer>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        const scoreEl = document.getElementById("score");
        const hitsEl = document.getElementById("hits");
        const statusEl = document.getElementById("status");
        const bulletSpeedSlider = document.getElementById("bulletSpeed");
        const bulletSpeedValue = document.getElementById("bulletSpeedValue");
        const inertiaSlider = document.getElementById("inertia");
        const inertiaValue = document.getElementById("inertiaValue");

        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;

        const PLAYER_SPEED = 200;
        const PLAYER_RADIUS = 18;
        const PLAYER_COLOR = "#5c7cfa";

        const ENEMY_COUNT = 5;
        const ENEMY_RADIUS = 20;
        const ENEMY_BASE_SPEED = 120;

        const BULLET_RADIUS = 4;
        const SHOOT_COOLDOWN = 180; // ms

        const PLAYER_INVULNERABLE_TIME = 1200; // ms after hit

        const keysDown = new Set();

        const state = {
            player: null,
            bullets: [],
            enemies: [],
            score: 0,
            hits: 0,
            lastShotTime: 0,
            lastFrame: null,
            statusTimer: 0,
            statusMessage: "",
            running: true,
            pendingReset: false
        };

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function spawnPlayer() {
            return {
                x: GAME_WIDTH / 2,
                y: GAME_HEIGHT - 70,
                vx: 0,
                vy: 0,
                facingX: 0,
                facingY: -1,
                invulnerable: 0
            };
        }

        function spawnEnemy() {
            let x, y;
            const margin = ENEMY_RADIUS + 20;
            do {
                x = randomRange(margin, GAME_WIDTH - margin);
                y = randomRange(margin, GAME_HEIGHT / 2);
            } while (distance(x, y, state.player.x, state.player.y) < 150);

            const angle = Math.random() * Math.PI * 2;
            return {
                x,
                y,
                vx: Math.cos(angle) * ENEMY_BASE_SPEED,
                vy: Math.sin(angle) * ENEMY_BASE_SPEED,
                baseSpeed: ENEMY_BASE_SPEED
            };
        }

        function resetGame(message = "") {
            state.player = spawnPlayer();
            state.bullets = [];
            state.enemies = Array.from({ length: ENEMY_COUNT }, () => spawnEnemy());
            state.score = 0;
            state.hits = 0;
            state.lastShotTime = 0;
            state.running = true;
            state.pendingReset = false;
            updateScore();
            setStatus(message);
        }

        function distance(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return Math.hypot(dx, dy);
        }

        function updateScore() {
            scoreEl.textContent = state.score;
            hitsEl.textContent = state.hits;
        }

        function setStatus(message, duration = 2000) {
            state.statusMessage = message;
            state.statusTimer = duration;
            statusEl.textContent = message;
        }

        function handleInput(dt) {
            let moveX = 0;
            let moveY = 0;

            if (keysDown.has("ArrowLeft")) moveX -= 1;
            if (keysDown.has("ArrowRight")) moveX += 1;
            if (keysDown.has("ArrowUp")) moveY -= 1;
            if (keysDown.has("ArrowDown")) moveY += 1;

            if (moveX !== 0 || moveY !== 0) {
                const mag = Math.hypot(moveX, moveY);
                moveX /= mag;
                moveY /= mag;
                state.player.facingX = moveX;
                state.player.facingY = moveY;
            }

            state.player.vx = moveX * PLAYER_SPEED;
            state.player.vy = moveY * PLAYER_SPEED;

            state.player.x += state.player.vx * dt;
            state.player.y += state.player.vy * dt;

            state.player.x = clamp(state.player.x, PLAYER_RADIUS, GAME_WIDTH - PLAYER_RADIUS);
            state.player.y = clamp(state.player.y, PLAYER_RADIUS, GAME_HEIGHT - PLAYER_RADIUS);

            if (state.player.invulnerable > 0) {
                state.player.invulnerable -= dt * 1000;
            }
        }

        function shoot() {
            const now = performance.now();
            if (now - state.lastShotTime < SHOOT_COOLDOWN || !state.running) {
                return;
            }
            state.lastShotTime = now;

            const dirX = state.player.facingX || 0;
            const dirY = state.player.facingY || -1;
            const length = Math.hypot(dirX, dirY) || 1;
            const normX = dirX / length;
            const normY = dirY / length;

            const speed = Number(bulletSpeedSlider.value);
            const bullet = {
                x: state.player.x + normX * (PLAYER_RADIUS + 5),
                y: state.player.y + normY * (PLAYER_RADIUS + 5),
                vx: normX * speed,
                vy: normY * speed
            };
            state.bullets.push(bullet);
        }

        function updateBullets(dt) {
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                const bullet = state.bullets[i];
                bullet.x += bullet.vx * dt;
                bullet.y += bullet.vy * dt;

                if (
                    bullet.x < -BULLET_RADIUS || bullet.x > GAME_WIDTH + BULLET_RADIUS ||
                    bullet.y < -BULLET_RADIUS || bullet.y > GAME_HEIGHT + BULLET_RADIUS
                ) {
                    state.bullets.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt) {
            const inertia = Number(inertiaSlider.value);
            const TAU = Math.PI * 2;

            for (const enemy of state.enemies) {
                const randomAngle = Math.random() * TAU;
                const randomSpeedX = Math.cos(randomAngle) * enemy.baseSpeed;
                const randomSpeedY = Math.sin(randomAngle) * enemy.baseSpeed;

                enemy.vx = inertia * enemy.vx + (1 - inertia) * randomSpeedX;
                enemy.vy = inertia * enemy.vy + (1 - inertia) * randomSpeedY;

                const speedMag = Math.hypot(enemy.vx, enemy.vy);
                if (speedMag > 0) {
                    const scale = enemy.baseSpeed / speedMag;
                    enemy.vx *= scale;
                    enemy.vy *= scale;
                }

                enemy.x += enemy.vx * dt;
                enemy.y += enemy.vy * dt;

                if (enemy.x < ENEMY_RADIUS) {
                    enemy.x = ENEMY_RADIUS;
                    enemy.vx *= -1;
                } else if (enemy.x > GAME_WIDTH - ENEMY_RADIUS) {
                    enemy.x = GAME_WIDTH - ENEMY_RADIUS;
                    enemy.vx *= -1;
                }

                if (enemy.y < ENEMY_RADIUS) {
                    enemy.y = ENEMY_RADIUS;
                    enemy.vy *= -1;
                } else if (enemy.y > GAME_HEIGHT - ENEMY_RADIUS) {
                    enemy.y = GAME_HEIGHT - ENEMY_RADIUS;
                    enemy.vy *= -1;
                }
            }
        }

        function checkCollisions() {
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                const bullet = state.bullets[i];

                for (let j = state.enemies.length - 1; j >= 0; j--) {
                    const enemy = state.enemies[j];
                    const dist = distance(bullet.x, bullet.y, enemy.x, enemy.y);
                    if (dist < ENEMY_RADIUS + BULLET_RADIUS + 2) {
                        state.enemies.splice(j, 1);
                        state.bullets.splice(i, 1);
                        state.score += 1;
                        updateScore();
                        setStatus("Inimigo eliminado!", 800);
                        break;
                    }
                }
            }

            if (state.player.invulnerable > 0) {
                return;
            }

            for (const enemy of state.enemies) {
                const dist = distance(state.player.x, state.player.y, enemy.x, enemy.y);
                if (dist < ENEMY_RADIUS + PLAYER_RADIUS - 6) {
                    state.hits += 1;
                    state.player.invulnerable = PLAYER_INVULNERABLE_TIME;
                    updateScore();
                    setStatus("Colisão! Cuidado...", 1000);
                    if (state.hits >= 3) {
                        endGame(false);
                    }
                    break;
                }
            }
        }

        function endGame(win) {
            state.running = false;
            if (win) {
                setStatus("Você venceu! Reiniciando...", 1800);
            } else {
                setStatus("Você perdeu! Reiniciando...", 1800);
            }
            if (!state.pendingReset) {
                state.pendingReset = true;
                setTimeout(() => resetGame(), 1800);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // background stars
            ctx.save();
            ctx.fillStyle = "rgba(255,255,255,0.06)";
            for (let i = 0; i < 80; i++) {
                ctx.fillRect((i * 73) % GAME_WIDTH, (i * 91) % GAME_HEIGHT, 2, 2);
            }
            ctx.restore();

            // draw player
            ctx.save();
            ctx.translate(state.player.x, state.player.y);
            ctx.rotate(Math.atan2(state.player.facingY, state.player.facingX) + Math.PI / 2);
            ctx.fillStyle = state.player.invulnerable > 0 ? "#ffd43b" : PLAYER_COLOR;
            ctx.beginPath();
            ctx.moveTo(0, -PLAYER_RADIUS);
            ctx.lineTo(PLAYER_RADIUS * 0.6, PLAYER_RADIUS);
            ctx.lineTo(-PLAYER_RADIUS * 0.6, PLAYER_RADIUS);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // draw bullets
            ctx.fillStyle = "#74c0fc";
            for (const bullet of state.bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, BULLET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }

            // draw enemies
            for (const enemy of state.enemies) {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.fillStyle = "#ff922b";
                ctx.beginPath();
                ctx.arc(0, 0, ENEMY_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#ffd8a8";
                ctx.beginPath();
                ctx.arc(-6, -4, 4, 0, Math.PI * 2);
                ctx.arc(6, -4, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            if (!state.running && state.pendingReset) {
                ctx.save();
                ctx.fillStyle = "rgba(11,15,26,0.6)";
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "bold 32px 'Segoe UI'";
                ctx.fillText(state.statusMessage, GAME_WIDTH / 2, GAME_HEIGHT / 2);
                ctx.restore();
            }
        }

        function loop(timestamp) {
            if (state.lastFrame === null) {
                state.lastFrame = timestamp;
            }
            const deltaMs = timestamp - state.lastFrame;
            const dt = Math.min(deltaMs / 1000, 0.05);
            state.lastFrame = timestamp;

            if (state.statusTimer > 0) {
                state.statusTimer -= deltaMs;
                if (state.statusTimer <= 0) {
                    statusEl.textContent = "";
                }
            }

            if (state.running) {
                handleInput(dt);
                updateBullets(dt);
                updateEnemies(dt);
                checkCollisions();

                if (state.score >= ENEMY_COUNT) {
                    endGame(true);
                }
            }

            draw();
            requestAnimationFrame(loop);
        }

        window.addEventListener("keydown", (event) => {
            if (event.code === "Space") {
                event.preventDefault();
                shoot();
            } else {
                keysDown.add(event.code);
            }
        });

        window.addEventListener("keyup", (event) => {
            keysDown.delete(event.code);
        });

        bulletSpeedSlider.addEventListener("input", () => {
            bulletSpeedValue.textContent = bulletSpeedSlider.value;
        });

        inertiaSlider.addEventListener("input", () => {
            inertiaValue.textContent = Number(inertiaSlider.value).toFixed(2);
        });

        bulletSpeedValue.textContent = bulletSpeedSlider.value;
        inertiaValue.textContent = Number(inertiaSlider.value).toFixed(2);

        resetGame("Prepare-se!");
        requestAnimationFrame(loop);
    </script>
</body>
</html>
